using HealthLink.Api.Data;
using HealthLink.Api.Dtos.Expert;
using HealthLink.Api.Entities.Enums;
using HealthLink.Api.Services.Interfaces;

using Microsoft.EntityFrameworkCore;

namespace HealthLink.Api.Services
{
    public class ExpertAvailabilityService : IExpertAvailabilityService
    {
        private readonly AppDbContext _db;

        public ExpertAvailabilityService(AppDbContext db)
        {
            _db = db;
        }

        public async Task<IReadOnlyList<ExpertAvailabilitySlotResponse>> GetDailyAvailabilityAsync(
            long expertId,
            DateOnly date)
        {
            var expertExists = await _db.Experts
                .AnyAsync(x => x.Id == expertId && x.IsActive);

            if (!expertExists)
                throw new InvalidOperationException("Expert not found");

            var dayOfWeek = (int)date.DayOfWeek;

            var template = await _db.ExpertScheduleTemplates
                .Include(x => x.TimeSlots)
                .FirstOrDefaultAsync(x =>
                    x.ExpertId == expertId &&
                    x.DayOfWeek == dayOfWeek &&
                    x.IsOpen);

            if (template == null || template.TimeSlots.Count == 0)
                return Array.Empty<ExpertAvailabilitySlotResponse>();

            // Session duration
            var durationMinutes = await _db.SystemSettings
                .Where(x => x.Key == "Session.DefaultDurationMinutes")
                .Select(x => int.Parse(x.Value))
                .FirstAsync();

            // Exceptions
            var exceptions = await _db.ExpertScheduleExceptions
                .Where(x => x.ExpertId == expertId && x.Date == date)
                .ToListAsync();

            // Existing appointments
            var dateTime = DateTime.SpecifyKind(date.ToDateTime(TimeOnly.MinValue), DateTimeKind.Utc);
            var appointments = await _db.Appointments
                .Where(x =>
                    x.ExpertId == expertId &&
                    x.StartDateTime.Date == dateTime.Date &&
                    x.Status == AppointmentStatus.Scheduled)
                .ToListAsync();

            var slots = new List<ExpertAvailabilitySlotResponse>();

            // Get manually created availability slots from database
            var manualSlots = await _db.ExpertAvailabilitySlots
                .Where(x => 
                    x.ExpertId == expertId && 
                    x.StartDateTime.Date == dateTime.Date)
                .ToListAsync();

            // Only return manual slots - no template-based generation
            foreach (var manualSlot in manualSlots)
            {
                // Check if blocked by appointment
                var blockedByAppointment = appointments.Any(a =>
                    a.StartDateTime < manualSlot.EndDateTime &&
                    a.EndDateTime > manualSlot.StartDateTime);

                // If blocked by appointment, override status to Booked
                var status = blockedByAppointment ? SlotStatus.Booked : manualSlot.Status;

                slots.Add(new ExpertAvailabilitySlotResponse
                {
                    StartDateTime = manualSlot.StartDateTime,
                    EndDateTime = manualSlot.EndDateTime,
                    Status = status,
                    IsAutoGenerated = false // Manual slots only
                });
            }

            return slots.OrderBy(s => s.StartDateTime).ToArray();
        }
    }
}

